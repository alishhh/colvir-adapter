// Code generated by xgen. DO NOT EDIT.

package schema

import (
	"encoding/xml"
)

type CustomConditionEqual struct {
	XMLName xml.Name `xml:"equals"`
	Attr string `xml:"attr,attr"`
	Value string `xml:"value"`
}

// ConditionType ...
type ConditionType struct {
	Attr string `xml:"attr,attr"`
	Value string `xml:"value"`
}

// ConditionElem ...
type ConditionElem *ConditionType

// ConditionNot ...
type ConditionNot struct {
	QueryConditionElem *ConditionType `xml:"query:ConditionElem"`
	*ConditionType
}

// Not ...
type Not *ConditionNot

// ConditionList ...
type ConditionList struct {
	QueryConditionElem []*ConditionType `xml:"query:ConditionElem"`
	*ConditionType
}

// ConditionOr ...
type ConditionOr struct {
	*ConditionList
}

// Or ...
type Or *ConditionOr

// ConditionAnd ...
type ConditionAnd struct {
	*ConditionList
}

// And ...
type And *ConditionAnd

// OperatorCondition ...
type OperatorCondition struct {
	AttrAttr string `xml:"attr,attr,omitempty"`
	*ConditionType
}

// BinaryOperatorCondition ...
type BinaryOperatorCondition struct {
	Value *ConditionValue `xml:"value"`
	*OperatorCondition
}

// ConditionIsNull ...
type ConditionIsNull struct {
	*OperatorCondition
}

// IsNull ...
type IsNull *ConditionIsNull

// ConditionIsNotNull ...
type ConditionIsNotNull struct {
	*OperatorCondition
}

// IsNotNull ...
type IsNotNull *ConditionIsNotNull

// ConditionEquals ...
type ConditionEquals struct {
	*BinaryOperatorCondition
}

// Equals ...
type Equals *ConditionEquals

// ConditionLike ...
type ConditionLike struct {
	*BinaryOperatorCondition
}

// Like ...
type Like *ConditionLike

// ConditionNotEquals ...
type ConditionNotEquals struct {
	*BinaryOperatorCondition
}

// NotEquals ...
type NotEquals *ConditionNotEquals

// ConditionIEquals ...
type ConditionIEquals struct {
	*BinaryOperatorCondition
}

// IEquals ...
type IEquals *ConditionIEquals

// ConditionILike ...
type ConditionILike struct {
	*BinaryOperatorCondition
}

// ILike ...
type ILike *ConditionILike

// ConditionINotEquals ...
type ConditionINotEquals struct {
	*BinaryOperatorCondition
}

// INotEquals ...
type INotEquals *ConditionINotEquals

// ConditionLessThan ...
type ConditionLessThan struct {
	*BinaryOperatorCondition
}

// LessThan ...
type LessThan *ConditionLessThan

// ConditionLessOrEquals ...
type ConditionLessOrEquals struct {
	*BinaryOperatorCondition
}

// LessOrEquals ...
type LessOrEquals *ConditionLessOrEquals

// ConditionGreaterThan ...
type ConditionGreaterThan struct {
	*BinaryOperatorCondition
}

// GreaterThan ...
type GreaterThan *ConditionGreaterThan

// ConditionGreaterOrEquals ...
type ConditionGreaterOrEquals struct {
	*BinaryOperatorCondition
}

// GreaterOrEquals ...
type GreaterOrEquals *ConditionGreaterOrEquals

// ConditionBetween ...
type ConditionBetween struct {
	Value []*ConditionValue `xml:"value"`
	*OperatorCondition
}

// Between ...
type Between *ConditionBetween

// ConditionIn ...
type ConditionIn struct {
	Value []*ConditionValue `xml:"value"`
	*OperatorCondition
}

// In ...
type In *ConditionIn

// ConditionInline ...
type ConditionInline struct {
	Sql string `xml:"sql"`
	*OperatorCondition
}

// Inline ...
type Inline *ConditionInline

// ConditionValue ...
type ConditionValue struct {
	TypeAttr string `xml:"type,attr,omitempty"`
	Value    string `xml:",chardata"`
}

// ConditionValueType ...
type ConditionValueType string

// SortOrderType ...
type SortOrderType string

// SortOrderField ...
type SortOrderField struct {
	CodeAttr string `xml:"code,attr,omitempty"`
	TypeAttr string `xml:"type,attr,omitempty"`
}

// SortOrder ...
type SortOrder struct {
	Field []*SortOrderField `xml:"field"`
}
